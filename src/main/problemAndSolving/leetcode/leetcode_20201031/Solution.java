package main.problemAndSolving.leetcode.leetcode_20201031;

//给定一个Excel表格中的列名称，返回其相应的列序号。
//
// 例如， 
//
//     A -> 1
//    B -> 2
//    C -> 3
//    ...
//    Z -> 26
//    AA -> 27
//    AB -> 28 
//    ...
// 
//
// 示例 1: 
//
// 输入: "A"
//输出: 1
// 
//
// 示例 2: 
//
// 输入: "AB"
//输出: 28
// 
//
// 示例 3: 
//
// 输入: "ZY"
//输出: 701 
//
// 致谢： 
//特别感谢 @ts 添加此问题并创建所有测试用例。 
// Related Topics 数学
// 很简单的26转10的类似进制转换的弱智题目
// 执行耗时:1 ms,击败了100.00% 的Java用户
//		内存消耗:38.5 MB,击败了9.26% 的Java用户
public class Solution {
    public int titleToNumber(String s) {
        char[] chars = s.toCharArray();
        int res = 0;
        for (char c :
                chars) {
            res = (res * 26 + (c - 'A' + 1));
        }
        return res;
    }

    //给定一个整数 n，返回 n! 结果尾数中零的数量。
//
// 示例 1:
//
// 输入: 3
//输出: 0
//解释: 3! = 6, 尾数中没有零。
//
// 示例 2:
//
// 输入: 5
//输出: 1
//解释: 5! = 120, 尾数中有 1 个零.
//
// 说明: 你算法的时间复杂度应为 O(log n) 。
// Related Topics 数学
    //调试了那么多次，终于最后一次最短最优的代码通过了，性能表现较优，用时：112m
    // 代码简单，但是相关的优化思想思路并不简单
    // 执行耗时:1 ms,击败了99.67% 的Java用户
    //		内存消耗:35.5 MB,击败了78.59% 的Java用户
    //当10出现时，末尾必定多一个0，当5出现时，由于阶乘，5出现前的结果一定是偶数（偶数因子一定比5因子多），相乘则多一个0
    public int trailingZeroes(int n) {
        int temp = n;
        int res = 0;
        //优化思路；每个10都与其前紧邻的5一一对应，最后的几个数中可能含一个5，单独计算
        //补充：25、125等5的次方中含有多个5，额外计算

        //优化2：每个10可看作5的倍数之一，5的次方数同是，同时末尾的5无需另作判断

        //计算5的个数
        while (temp > 0) {
            temp /= 5;
            res += temp;
        }
//        // 乘2得5和10的总数（成对）
//        res <<= 1;
//        //计算5的次方数
//        temp = 5;
//        for (int i = 0; temp < n; i++) {
//            res += i;//res+=(i+1-1)
//            temp *= 5;
//        }
//        //然后判断最后几个数是否含5
//        if ((n % 10) > 4) {
//            res++;
//        }
        return res;
    }
}
